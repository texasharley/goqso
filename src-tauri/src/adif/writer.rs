// ADIF Writer
// Exports QSOs to ADIF format

use std::collections::HashMap;

/// Write an ADIF file from records
pub fn write_adif(records: &[HashMap<String, String>], program_id: &str) -> String {
    let mut output = String::new();
    
    // Header
    output.push_str(&format!("Generated by {} on {}\n", program_id, chrono::Utc::now().format("%Y-%m-%d %H:%M:%S")));
    output.push_str(&format!("<PROGRAMID:{}>{}\n", program_id.len(), program_id));
    output.push_str("<ADIF_VER:5>3.1.4\n");
    output.push_str("<EOH>\n\n");
    
    // Records
    for record in records {
        for (key, value) in record {
            if !value.is_empty() {
                output.push_str(&format!("<{}:{}>{}", key.to_uppercase(), value.len(), value));
            }
        }
        output.push_str("<EOR>\n\n");
    }
    
    output
}

/// Standard ADIF fields we export (in order)
pub const EXPORT_FIELDS: &[&str] = &[
    // Core
    "CALL", "QSO_DATE", "TIME_ON", "TIME_OFF", "BAND", "FREQ", "MODE", "SUBMODE",
    // Signal
    "RST_SENT", "RST_RCVD", "TX_PWR",
    // Location
    "DXCC", "COUNTRY", "STATE", "CNTY", "GRIDSQUARE", "CQZ", "ITUZ", "CONT",
    // Station
    "NAME", "QTH", "COMMENT", "NOTES",
    // My station
    "STATION_CALLSIGN", "MY_GRIDSQUARE", "MY_STATE", "MY_CNTY",
    // QSL
    "QSL_SENT", "QSL_SENT_VIA", "QSL_RCVD", "QSL_RCVD_VIA", "LOTW_QSL_SENT", "LOTW_QSL_RCVD",
    "EQSL_QSL_SENT", "EQSL_QSL_RCVD",
    // Propagation
    "PROP_MODE", "SAT_NAME", "SAT_MODE",
    // Awards
    "IOTA", "SOTA_REF", "POTA_REF", "WWFF_REF", "SIG", "SIG_INFO",
    // Contest
    "CONTEST_ID", "SRX", "STX", "SRX_STRING", "STX_STRING",
    // Equipment
    "RIG", "ANT", "ANT_AZ", "ANT_EL",
];

/// Convert a QSO from our database format to ADIF HashMap
pub fn qso_to_adif(qso: &serde_json::Value) -> HashMap<String, String> {
    let mut map = HashMap::new();
    
    // Direct field mappings (db_field -> ADIF_FIELD)
    let mappings = [
        // Core
        ("call", "CALL"),
        ("qso_date", "QSO_DATE"),
        ("qso_date_off", "QSO_DATE_OFF"),
        ("time_on", "TIME_ON"),
        ("time_off", "TIME_OFF"),
        ("band", "BAND"),
        ("mode", "MODE"),
        ("submode", "SUBMODE"),
        // Signal
        ("rst_sent", "RST_SENT"),
        ("rst_rcvd", "RST_RCVD"),
        // Location
        ("country", "COUNTRY"),
        ("state", "STATE"),
        ("cnty", "CNTY"),
        ("gridsquare", "GRIDSQUARE"),
        ("continent", "CONT"),
        // Propagation
        ("prop_mode", "PROP_MODE"),
        ("sat_name", "SAT_NAME"),
        // Activity references
        ("iota", "IOTA"),
        ("pota_ref", "POTA_REF"),
        ("sota_ref", "SOTA_REF"),
        ("wwff_ref", "WWFF_REF"),
        ("pfx", "PFX"),
        // Operator info
        ("name", "NAME"),
        ("qth", "QTH"),
        ("comment", "COMMENT"),
        ("arrl_sect", "ARRL_SECT"),
        // My station
        ("station_callsign", "STATION_CALLSIGN"),
        ("operator", "OPERATOR"),
        ("my_gridsquare", "MY_GRIDSQUARE"),
        ("my_cnty", "MY_CNTY"),
        ("my_arrl_sect", "MY_ARRL_SECT"),
        ("my_sota_ref", "MY_SOTA_REF"),
        ("my_pota_ref", "MY_POTA_REF"),
    ];
    
    for (db_field, adif_field) in mappings {
        if let Some(val) = qso.get(db_field).and_then(|v| v.as_str()) {
            if !val.is_empty() {
                map.insert(adif_field.to_string(), val.to_string());
            }
        }
    }
    
    // Numeric fields
    if let Some(freq) = qso.get("freq").and_then(|v| v.as_f64()) {
        map.insert("FREQ".to_string(), format!("{:.6}", freq));
    }
    if let Some(dxcc) = qso.get("dxcc").and_then(|v| v.as_i64()) {
        map.insert("DXCC".to_string(), dxcc.to_string());
    }
    if let Some(cqz) = qso.get("cqz").and_then(|v| v.as_i64()) {
        map.insert("CQZ".to_string(), cqz.to_string());
    }
    if let Some(ituz) = qso.get("ituz").and_then(|v| v.as_i64()) {
        map.insert("ITUZ".to_string(), ituz.to_string());
    }
    if let Some(pwr) = qso.get("tx_pwr").and_then(|v| v.as_f64()) {
        map.insert("TX_PWR".to_string(), pwr.to_string());
    }
    
    // Extended fields from adif_fields JSON blob
    if let Some(adif_json) = qso.get("adif_fields").and_then(|v| v.as_str()) {
        if let Ok(adif_obj) = serde_json::from_str::<serde_json::Value>(adif_json) {
            if let Some(obj) = adif_obj.as_object() {
                for (key, val) in obj {
                    if let Some(s) = val.as_str() {
                        if !s.is_empty() {
                            map.insert(key.to_uppercase(), s.to_string());
                        }
                    }
                }
            }
        }
    }
    
    map
}
