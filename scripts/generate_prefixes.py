#!/usr/bin/env python3
"""
Generate prefixes.rs from prefix_rules.json

This script generates the Rust source file for prefix-to-DXCC mappings
from the authoritative JSON source.

DO NOT manually edit prefixes.rs - regenerate it with this script.

Usage:
    python scripts/generate_prefixes.py
    
Validation:
    cargo test reference::prefixes
    cargo clippy -- -A dead_code -A unused_imports
"""

import json
from pathlib import Path
from datetime import datetime
from collections import defaultdict

def load_prefix_rules(json_path: Path) -> dict:
    """Load prefix rules from JSON."""
    with open(json_path, 'r') as f:
        return json.load(f)

def group_rules_by_region(rules: list) -> dict:
    """Group rules by geographic region for organized output."""
    # Map entity_ids to regions based on continent/area
    # This is for code organization only, not functionality
    regions = {
        'north_america': [],
        'caribbean': [],
        'central_america': [],
        'south_america': [],
        'europe': [],
        'asia': [],
        'oceania': [],
        'africa': [],
        'antarctica': [],
        'other': [],
    }
    
    # Entity ID ranges for rough classification (simplified)
    # In practice, we'll just output alphabetically by prefix
    return {'all': rules}

def generate_rust_file(rules_data: dict, output_path: Path):
    """Generate the Rust prefixes.rs file."""
    
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')
    rules = rules_data['rules']
    stats = rules_data['stats']
    
    # Sort rules: by prefix alphabetically, then by priority descending
    # This makes the file readable while lookup_callsign handles matching
    sorted_rules = sorted(rules, key=lambda r: (r['prefix'], -r['priority']))
    
    # Build Rust source
    lines = []
    
    # Header
    lines.append('//! Prefix to DXCC Entity mapping')
    lines.append('//!')
    lines.append('//! DO NOT EDIT THIS FILE DIRECTLY')
    lines.append('//!')
    lines.append(f'//! Generated from: src-tauri/resources/prefix_rules.json')
    lines.append(f'//! Generator: scripts/generate_prefixes.py')
    lines.append(f'//! Generated: {timestamp}')
    lines.append('//!')
    lines.append(f'//! Statistics:')
    lines.append(f'//!   Total rules: {stats["total_rules"]}')
    lines.append(f'//!   Entities covered: {stats["entities_covered"]}/{stats["active_entities"]}')
    lines.append(f'//!   Coverage: {stats["coverage_percent"]}%')
    lines.append('//!')
    lines.append('//! To update: modify prefix_rules.json and run:')
    lines.append('//!   python scripts/generate_prefixes.py')
    lines.append('//!')
    lines.append('//! Source: ARRL DXCC list + ITU Radio Regulations + operator conventions')
    lines.append('//! Authority: https://www.arrl.org/files/file/DXCC/Current_Deleted.txt')
    lines.append('')
    lines.append('/// A prefix rule for matching callsigns to DXCC entities')
    lines.append('#[derive(Debug, Clone)]')
    lines.append('pub struct PrefixRule {')
    lines.append('    /// The prefix pattern (e.g., "W", "VE", "JA")')
    lines.append('    pub prefix: &\'static str,')
    lines.append('    /// The DXCC entity ID (ARRL 3-digit format: "001", "291", etc.)')
    lines.append('    pub entity_id: &\'static str,')
    lines.append('    /// Optional: exact match only (for special calls)')
    lines.append('    pub exact: bool,')
    lines.append('    /// Priority for overlapping prefixes (higher = more specific)')
    lines.append('    pub priority: u8,')
    lines.append('}')
    lines.append('')
    lines.append('/// Prefix rules generated from prefix_rules.json')
    lines.append(f'/// Total: {len(sorted_rules)} rules covering {stats["entities_covered"]} DXCC entities')
    lines.append('pub const PREFIX_RULES: &[PrefixRule] = &[')
    
    # Group by first character for readability
    current_first_char = None
    for rule in sorted_rules:
        prefix = rule['prefix']
        first_char = prefix[0] if prefix else '?'
        
        # Add section comment when first character changes
        if first_char != current_first_char:
            if current_first_char is not None:
                lines.append('')
            lines.append(f'    // === {first_char} ===')
            current_first_char = first_char
        
        entity_id = rule['entity_id']  # Already 3-digit string from JSON
        exact = 'true' if rule.get('exact', False) else 'false'
        priority = rule.get('priority', 10)
        comment = rule.get('comment', '')
        
        # Format the rule - entity_id is now a string literal
        rule_line = f'    PrefixRule {{ prefix: "{prefix}", entity_id: "{entity_id}", exact: {exact}, priority: {priority} }},'
        
        # Add comment if present
        if comment:
            # Truncate long comments
            if len(comment) > 40:
                comment = comment[:37] + '...'
            rule_line += f' // {comment}'
        
        lines.append(rule_line)
    
    lines.append('];')
    lines.append('')
    
    # Add lookup function
    lines.append('/// Look up the DXCC entity for a callsign')
    lines.append('/// Uses longest prefix match with priority ordering')
    lines.append('/// Returns ARRL 3-digit entity ID (e.g., "291" for USA)')
    lines.append('pub fn lookup_callsign(callsign: &str) -> Option<&\'static str> {')
    lines.append('    let call_upper = callsign.to_uppercase();')
    lines.append('')
    lines.append('    // Find all matching prefixes, sorted by prefix length (longest first) then priority')
    lines.append('    let mut matches: Vec<&PrefixRule> = PREFIX_RULES')
    lines.append('        .iter()')
    lines.append('        .filter(|rule| {')
    lines.append('            if rule.exact {')
    lines.append('                call_upper == rule.prefix')
    lines.append('            } else {')
    lines.append('                call_upper.starts_with(rule.prefix)')
    lines.append('            }')
    lines.append('        })')
    lines.append('        .collect();')
    lines.append('')
    lines.append('    // Sort by prefix length (descending) then priority (descending)')
    lines.append('    matches.sort_by(|a, b| {')
    lines.append('        let len_cmp = b.prefix.len().cmp(&a.prefix.len());')
    lines.append('        if len_cmp == std::cmp::Ordering::Equal {')
    lines.append('            b.priority.cmp(&a.priority)')
    lines.append('        } else {')
    lines.append('            len_cmp')
    lines.append('        }')
    lines.append('    });')
    lines.append('')
    lines.append('    matches.first().map(|rule| rule.entity_id)')
    lines.append('}')
    lines.append('')
    
    # Add get_prefixes_for_entity function
    lines.append('/// Get all prefixes for a given entity')
    lines.append('/// entity_id should be ARRL 3-digit format (e.g., "291")')
    lines.append('#[allow(dead_code)]')
    lines.append('pub fn get_prefixes_for_entity(entity_id: &str) -> Vec<&\'static str> {')
    lines.append('    PREFIX_RULES')
    lines.append('        .iter()')
    lines.append('        .filter(|rule| rule.entity_id == entity_id)')
    lines.append('        .map(|rule| rule.prefix)')
    lines.append('        .collect()')
    lines.append('}')
    lines.append('')
    
    # Add tests
    lines.append('#[cfg(test)]')
    lines.append('mod tests {')
    lines.append('    use super::*;')
    lines.append('')
    lines.append('    #[test]')
    lines.append('    fn test_us_callsigns() {')
    lines.append('        assert_eq!(lookup_callsign("W1AW"), Some("291"));')
    lines.append('        assert_eq!(lookup_callsign("K5ABC"), Some("291"));')
    lines.append('        assert_eq!(lookup_callsign("N7XYZ"), Some("291"));')
    lines.append('        assert_eq!(lookup_callsign("AA1BB"), Some("291"));')
    lines.append('        assert_eq!(lookup_callsign("KB9FIN"), Some("291"));')
    lines.append('    }')
    lines.append('')
    lines.append('    #[test]')
    lines.append('    fn test_us_territories() {')
    lines.append('        assert_eq!(lookup_callsign("KH6ABC"), Some("110")); // Hawaii')
    lines.append('        assert_eq!(lookup_callsign("KL7ABC"), Some("006"));   // Alaska')
    lines.append('        assert_eq!(lookup_callsign("KP4ABC"), Some("202")); // Puerto Rico')
    lines.append('        assert_eq!(lookup_callsign("KP2ABC"), Some("285")); // US Virgin Islands')
    lines.append('    }')
    lines.append('')
    lines.append('    #[test]')
    lines.append('    fn test_caribbean_british() {')
    lines.append('        assert_eq!(lookup_callsign("VP2MXY"), Some("096"));  // Montserrat')
    lines.append('        assert_eq!(lookup_callsign("VP2EAB"), Some("012"));  // Anguilla')
    lines.append('        assert_eq!(lookup_callsign("VP2VAB"), Some("065"));  // British Virgin Islands')
    lines.append('        assert_eq!(lookup_callsign("VP5ABC"), Some("089"));  // Turks & Caicos')
    lines.append('        assert_eq!(lookup_callsign("VP9ABC"), Some("064"));  // Bermuda')
    lines.append('        assert_eq!(lookup_callsign("ZF1ABC"), Some("069"));  // Cayman Islands')
    lines.append('    }')
    lines.append('')
    lines.append('    #[test]')
    lines.append('    fn test_caribbean_nations() {')
    lines.append('        assert_eq!(lookup_callsign("V26ABC"), Some("094"));  // Antigua & Barbuda')
    lines.append('        assert_eq!(lookup_callsign("V31ABC"), Some("066"));  // Belize')
    lines.append('        assert_eq!(lookup_callsign("V47ABC"), Some("249")); // St. Kitts & Nevis')
    lines.append('        assert_eq!(lookup_callsign("C6ABC"), Some("060"));   // Bahamas')
    lines.append('        assert_eq!(lookup_callsign("6Y5ABC"), Some("082"));  // Jamaica')
    lines.append('        assert_eq!(lookup_callsign("8P6ABC"), Some("062"));  // Barbados')
    lines.append('        assert_eq!(lookup_callsign("9Y4ABC"), Some("090"));  // Trinidad & Tobago')
    lines.append('        assert_eq!(lookup_callsign("9Y4DG"), Some("090"));   // Trinidad (bug report)')
    lines.append('        assert_eq!(lookup_callsign("V47T"), Some("249"));   // St. Kitts (bug report)')
    lines.append('        assert_eq!(lookup_callsign("J38ABC"), Some("077"));  // Grenada')
    lines.append('        assert_eq!(lookup_callsign("J68ABC"), Some("097"));  // St. Lucia')
    lines.append('        assert_eq!(lookup_callsign("J79ABC"), Some("095"));  // Dominica')
    lines.append('        assert_eq!(lookup_callsign("J88ABC"), Some("098"));  // St. Vincent')
    lines.append('    }')
    lines.append('')
    lines.append('    #[test]')
    lines.append('    fn test_caribbean_other() {')
    lines.append('        assert_eq!(lookup_callsign("CO8LY"), Some("070"));   // Cuba')
    lines.append('        assert_eq!(lookup_callsign("HI3ABC"), Some("072"));  // Dominican Republic')
    lines.append('        assert_eq!(lookup_callsign("HH2ABC"), Some("078"));  // Haiti')
    lines.append('        assert_eq!(lookup_callsign("FM5ABC"), Some("084"));  // Martinique')
    lines.append('        assert_eq!(lookup_callsign("FG5ABC"), Some("079"));  // Guadeloupe')
    lines.append('        assert_eq!(lookup_callsign("PJ2ABC"), Some("517")); // Curacao')
    lines.append('        assert_eq!(lookup_callsign("PJ4ABC"), Some("520")); // Bonaire')
    lines.append('        assert_eq!(lookup_callsign("PJ7ABC"), Some("518")); // Sint Maarten')
    lines.append('        assert_eq!(lookup_callsign("P40ABC"), Some("091"));  // Aruba')
    lines.append('    }')
    lines.append('')
    lines.append('    #[test]')
    lines.append('    fn test_central_america() {')
    lines.append('        assert_eq!(lookup_callsign("TI2ABC"), Some("308")); // Costa Rica')
    lines.append('        assert_eq!(lookup_callsign("TG9ABC"), Some("076"));  // Guatemala')
    lines.append('        assert_eq!(lookup_callsign("HR2ABC"), Some("080"));  // Honduras')
    lines.append('        assert_eq!(lookup_callsign("YN2ABC"), Some("086"));  // Nicaragua')
    lines.append('        assert_eq!(lookup_callsign("YS1ABC"), Some("074"));  // El Salvador')
    lines.append('        assert_eq!(lookup_callsign("HP1ABC"), Some("088"));  // Panama')
    lines.append('    }')
    lines.append('')
    lines.append('    #[test]')
    lines.append('    fn test_south_america() {')
    lines.append('        assert_eq!(lookup_callsign("YV5ABC"), Some("148")); // Venezuela')
    lines.append('        assert_eq!(lookup_callsign("HK3ABC"), Some("116")); // Colombia')
    lines.append('        assert_eq!(lookup_callsign("HC2ABC"), Some("120")); // Ecuador')
    lines.append('        assert_eq!(lookup_callsign("HC8ABC"), Some("071"));  // Galapagos')
    lines.append('        assert_eq!(lookup_callsign("OA4ABC"), Some("136")); // Peru')
    lines.append('        assert_eq!(lookup_callsign("CP6ABC"), Some("104")); // Bolivia')
    lines.append('        assert_eq!(lookup_callsign("CE3ABC"), Some("112")); // Chile')
    lines.append('        assert_eq!(lookup_callsign("LU1ABC"), Some("100")); // Argentina')
    lines.append('        assert_eq!(lookup_callsign("PY2ABC"), Some("108")); // Brazil')
    lines.append('        assert_eq!(lookup_callsign("ZP5ABC"), Some("132")); // Paraguay')
    lines.append('        assert_eq!(lookup_callsign("CX2ABC"), Some("144")); // Uruguay')
    lines.append('    }')
    lines.append('')
    lines.append('    #[test]')
    lines.append('    fn test_japan() {')
    lines.append('        assert_eq!(lookup_callsign("JA1ABC"), Some("339"));')
    lines.append('        assert_eq!(lookup_callsign("JH1NBN"), Some("339"));')
    lines.append('        assert_eq!(lookup_callsign("7K1ABC"), Some("339"));')
    lines.append('    }')
    lines.append('')
    lines.append('    #[test]')
    lines.append('    fn test_germany() {')
    lines.append('        assert_eq!(lookup_callsign("DL1ABC"), Some("230"));')
    lines.append('        assert_eq!(lookup_callsign("DJ5XYZ"), Some("230"));')
    lines.append('    }')
    lines.append('')
    lines.append('    #[test]')
    lines.append('    fn test_uk() {')
    lines.append('        assert_eq!(lookup_callsign("G3ABC"), Some("223"));  // England')
    lines.append('        assert_eq!(lookup_callsign("GM3ABC"), Some("279")); // Scotland')
    lines.append('        assert_eq!(lookup_callsign("GW3ABC"), Some("294")); // Wales')
    lines.append('    }')
    lines.append('')
    lines.append('    #[test]')
    lines.append('    fn test_hk0_san_andres() {')
    lines.append('        // HK0 prefix should map to San Andres & Providencia (entity 216)')
    lines.append('        assert_eq!(lookup_callsign("HK0ABC"), Some("216"));')
    lines.append('    }')
    lines.append('}')
    
    # Write to file
    with open(output_path, 'w', newline='\n') as f:
        f.write('\n'.join(lines))
    
    print(f"Generated {output_path}")
    print(f"  Total rules: {len(sorted_rules)}")
    print(f"  Coverage: {stats['entities_covered']}/{stats['active_entities']} entities")


def main():
    base = Path(__file__).parent.parent
    json_path = base / "src-tauri" / "resources" / "prefix_rules.json"
    output_path = base / "src-tauri" / "src" / "reference" / "prefixes.rs"
    
    print("Loading prefix rules...")
    rules_data = load_prefix_rules(json_path)
    
    print("Generating prefixes.rs...")
    generate_rust_file(rules_data, output_path)
    
    print("\nValidation commands:")
    print("  cargo test reference::prefixes")
    print("  cargo clippy")


if __name__ == "__main__":
    main()
